---
title: "AWS Lambda Setup with Docker"
date: 8/7/2024
slug: lambda-deployment
keywords: [AWS, Lambda, AWS Lambda, Amazon Web Serivces, Lambda Python, AWS Lamba Python]
description: A quick guide to deploying a Python-based AWS Lambda function
---

<PostHeader title="AWS Lambda Setup with Docker" date={new Date("08/07/2024")}/>

I recently got to play around with deploying [Lambda](https://aws.amazon.com/lambda/) functions on AWS, which wasn't as straightforward as I imagined. To serve as future reference, here are the steps I took to launch an AWS Lambda function running in a Docker environment. 

# The structure of a Lambda function

A [serverless function](https://www.cloudflare.com/learning/serverless/glossary/function-as-a-service-faas/) is like a regular function in a programming language, except cloud-hosted and fully-managed. All you have to do is provide a function definition (+ any dependencies), and the serverless function will run your logic whenever triggered.

With serverless functions, core app logic can be decoupled into individually scalable and serviceable pieces, speeding up development and improving application uptime. It's no surprise then that serverless functions are a great building block for today's applications.

It's not surprising then that a Lambda function is literally defined by a _handler function_ in the actual code:

```py
def lambda_handler(event, context):
    pass
```

`lambda_handler()` would act as the handler for the Lambda instance if we tell AWS that it is the entrypoint. Then AWS Lambda will call `lambda_handler()` whenever the Lambda is triggered. This function takes in two important parameters:
- `event` - a dictionary containing the JSON payload for the triggering event. You define the contents of the payload when defining a trigger. 
- `context` - information about the current execution environment. See the [docs](https://docs.aws.amazon.com/lambda/latest/dg/python-context.html) for the type of information that included in the context.

You can import modules or define variables and classes all outside the handler function - AWS Lambda will make sure to load those dependencies in. This allows you to develop the Lambda almost like it's just a locally running script - just make sure all the dependencies work correctly, and the Lambda should run fine!

# Dependencies and Containers
Ah, but as I learned the hard way, this last step is easier said than done. 
> just make sure all dependencies work correctly


It turns out that as per the [Lambda Python docs](https://docs.aws.amazon.com/lambda/latest/dg/lambda-python.html), there are two ways to setup runtime dependencies for a Python-based Lambda function.
1. [Upload a zip-file archive](https://docs.aws.amazon.com/lambda/latest/dg/python-package.html) containing the lambda function and related dependencies like third-party packages.
2. Provide a [container image](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html) compiled with the lambda function and related dependencies.

A zip-file archive is simple enough for basic lambda functions - but unfortunately this can get complicated quickly:
1. If you need access to a third-party package (say for example, [`requests`](https://requests.readthedocs.io/en/latest/), this package needs to be included in the archive, in a [very specific way](https://docs.aws.amazon.com/lambda/latest/dg/python-package.html#python-package-create-dependencies).
2. If a third-party package relies on binaries - like how [`polars`](https://pola.rs/) depends on binaries compiled from Rust - your lambda needs to have the right version of the binaries to execute on the target platform. 
3. If a package relies on some other set of headers of libraries, you may need to make sure the Lambda instance has those as well.

I learned (the hard way) about _all_ the possible ways I could have dependency issues when using a zip-file archive. 

This is where [containers](https://aws.amazon.com/what-is/containerization/) came to the rescue. With containers:
- Dependencies are installed for the target environment as part of the image definition -  this eliminates challenges where the wrong distribution of binaries are included. You will still need to be a bit careful with architecture though. 
- Installing extra libraries or headers can be more easily performed as part of the image compilation process.

In addition, AWS Lambda container images allow us to test functions locally in a (mostly) similar environment as production. This allows us to actually check that all dependencies and Lambda operations are running smoothly before deploying!

There are some tradeoffs though:
- maining the container images for your Lambda in [ECR](https://aws.amazon.com/ecr/) can be costly, especially for larger images that are more than 1 GB.
- running on a container can be a _bit_ slower than running natively on the target platform - although I suspect AWS already uses containerization even in the case of using zip-file archives, in which case this is a non-issue.

I was willing to bear those for my project - my image sizes were quite small as I only needed a few packages (plus I refactored my code to remove dependencies on Polars).

# Setting Up a Python-based Lambda Container

## Lambda Definition
